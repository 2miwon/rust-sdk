# `api_model` Macro Documentation

The `api_model` macro generates an API model with database and repository support.

## Features
- **Generates a database table** based on the struct definition.
- **Creates repository functions** (`insert`, `update`, `delete`, `find`, `find_one`, and functions to create tables).
- **Auto-generates API client functions** for RESTful interactions.
- **Supports action-based API calls** (`action` and `action_by_id`).
- **Integrates with SQLx for efficient database queries.**

---

## ðŸ“Œ Key Structures

### **1. Original Structure**
The main struct includes functions to obtain the `Client` (for web interactions) and `Repository` (for server-side operations).

- Given `ExampleModel` as an `api_model`, the following methods are available:
  - `ExampleModel::get_client(endpoint)` â†’ Returns `ExampleModelClient`
  - `ExampleModel::get_repository(postgres_pool)` â†’ Returns `ExampleModelRepository` (only for `server` feature)

### **2. API Client Structure**
- Named with the suffix `Client` (e.g., `ExampleModelClient`).
- Provides API actions based on the `base` attribute.

### **3. Repository Structure**
- Named with the suffix `Repository` (e.g., `ExampleModelRepository`).
- Used for direct database interactions (currently supports PostgreSQL).

### **4. Summary Model**
- Named with the suffix `Summary` (e.g., `ExampleModelSummary`).
- Used for bulk data retrieval in query actions.
- Includes only fields marked with `summary`.

---

## ðŸ“Œ Client Structure

### **Actions**

#### Types of Actions
- **Query Action (`query_action`, `queryable`)**
  - Describes bulk data listing.
  - Defined as a field attribute.

- **Read Action (`read_action`)**
  - Fetches a single entity by a unique identifier.

- **Action (`action`)**
  - Supports custom REST API actions.

- **Action by ID (`action_by_id`)**
  - Defines API actions that require an ID parameter.

#### Query Action (`query_action`, `queryable`)
Query action is used to retrieve multiple records from the database in a paginated manner.
It is automatically generated for models that have the `queryable` or `query_action` attribute defined in a field.

- It returns a paginated response wrapped in a `QueryResponse<T>` structure where `iter_type` is `QueryResponse`.
  - At this, `iter_type` must implement `From<(i64, T)>` trait.
- The query parameters such as `size` and `page` are supported to control the data retrieval.
- The response contains both the data and metadata (e.g., total count, pagination details).
- `Query param` structure, which is named by suffix of `Query` is composed with fields described as `queryable` or `query_action`

**Example Usage:**
```rust,no_run
let client = ExampleModel::get_client("https://api.example.com");
let query_params = ExampleModelQuery::new(10).with_page(2);
let response = client.query(query_params).await?;
println!("Total Count: {}", response.total_count);
for item in response.items {
    println!("ID: {}, Name: {}", item.id, item.name);
}
```

##### Differences between `queryable` and `query_action**
- `queryable` only makes a field to `Query` structure.
- `query_action` makes a field and a function to `Query** structure

**Example Usage:**

```rust,no_run
#[api_model(base = "/examples", iter_type = QueryResponse)]
pub struct ExampleModel {
    #[api_model(summary, primary_key)]
    pub id: String,
    #[api_model(summary, auto = [insert])]
    pub created_at: i64,
    #[api_model(summary, auto = [insert, update])]
    pub updated_at: i64,
    #[api_model(summary, query_action = list_by_status)]
    pub status: i32,
    #[api_model(summary)]
    pub area: String,
}

async fn test_query() {
   let cli = ExampleModel::get_client("http://localhost:3000");

   // it makes an API call to GET http://localhost:3000/examples?param-type=query&area=test_area&size=10
   // res will be `Result<QueryResponse<ExampleModel>>`. If `iter_type` is described as and other generic response, it will be the described type. Don't forget implementing `From<(i64,T)>` trait for the reponse type.
   // And also abbreviated Result must be defined or imported in this file.
   let res = cli.query(ExampleModelQuery::new(10).with_area("test_area")).await;

   // it makes an API call to GET http://localhost:3000/examples?param-type=query&area=test_area&size=10&page=2
   cli.query(ExampleModelQuery::new(10).with_page(2).with_area("test_area")).await;

   // `list_by_status` is generated by `query_action` attribute.
   // it makes an API call to GET http://localhost:3000/examples?param-type=query&status=3&size=10&page=2
   cli.list_by_status(10, 2.to_string(), 3).await;
}
```

##### Principle of query
For composition of query url, It uses `Param` structure. ex) `ExampleModelParam`.
It will declared as below:

```rust,no_run
#[serde(rename = "kebab-case", tag = "param-type")]
pub struct ExampleModelParam {
    Query(ExampleModelQuery)
    Read(ExampleModelReadAction)
}
```

If no `read_action`, `Param` is only declared with Query.
At this, `Query` is always defined even if no `queryable` or `query_action`.
If no `query*` is described, `ExampleModelQuery` only has `size` and `bookmark` fields.
Note that `page` will be described in `bookmark` as string in SQL.

##### Handling requests in server side
Server side handle can handle `Param` or `Query` structure.
If server side handler handle only `Query` like `ExampleModelQuery`, it ignores `param-type` query argument.
If you don't have a plan to support `read_action`, you can only hanle `Query` instead of `Param`.


#### Read Action (`read_action`)
Read action(`read_action`) can be described as an structure attribute or a field attribute.

##### Structure attribute
It can be formed by three types; a function only, multiple functions, functions with additional parameters.
Structure attribute can be utilized in two circumstances; 
- defining a API call without any parameter
- adding a custom field to a specific read action.

The below explains how to use `read_action` as structure attribute.

- The simplest definition defines only a function.
  - `read_action = get_data`
- Multiple functions define two or more functions.
  - `read_action = [get_data, verify]`
- Functions with additional parameter define functions with additional parameter, which this structure does not have.
  - `read_action = [get_data, verify(code = String, email = String)]`

##### Field attribute
It supports a single function and multiple functions form.
Also it allows you to change to a custom parameter type.
In contrast of `structure attiribute`, field

- a single and multiple functions definition are same with `structure attribute`.
  - `read_action = get_data`, `read_action = [get_data, verify]`
  - Basically, `read_action` in field attribute makes a field with the same type to `ReadAction` structure.
- If you want to change action type, you can use `related` attiribute.
  - `related = CustomActionRequest` makes `Client` use `CustomActionRequest`


#### Action (`action`)

#### Action by id (`action_by_id`)

## ðŸ“Œ Repository Structure

- Provides functions to interact with the database.
- Implements CRUD operations via SQLx.
- Automatically generates SQL table creation scripts.

#### Example Usage
```rust,no_run
let repo = ExampleModel::get_repository(pool);
let new_item = repo.insert("Example Name").await?;
let updated_item = repo.update("123", ExampleModelRepositoryUpdateRequest { name: Some("Updated") }).await?;
let deleted = repo.delete("123").await?;
```

---

## ðŸ“Œ Example

```rust,no_run
#[api_model(
    base = "/examples",
    table = example_table,
    iter_type = QueryResponse,
    action_by_id = delete,
    action = [no_param, empty]
)]
pub struct ExampleModel {
    #[api_model(summary, primary_key, read_action = find_by_id)]
    pub id: String,
    #[api_model(summary, auto = [insert])]
    pub created_at: i64,
    #[api_model(summary, auto = [insert, update])]
    pub updated_at: i64,
    #[api_model(summary)]
    pub name: String,
}
```

---

## **ðŸ“Œ Conclusion**
The `#[api_model]` macro automatically generates **database models, API request structures, clients, and action enums**.  
This enables **efficient RESTful API and database interactions**.

